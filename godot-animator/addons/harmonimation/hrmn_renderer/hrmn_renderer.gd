@tool

class_name HarmonimationPlayer
extends AnimationPlayer

## Data from music score, provided to animation widgets
@export var music_data: MusicScoreData:
	# TODO: catch signals from json data changing
	set(val):
		music_data = val
		if is_node_ready():
			apply_animations()

# TODO: add label to indicate current JSON load state
# TODO: add button to force manually re-compute json


# TODO: auto-discover mode
## Animation widgets, provided data from music score
@export var widgets: Array[HarmonimationWidget] = []:
	set(val):
		widgets = val
		if is_node_ready():
			apply_animations()


## Current animation being created. Only non-null while animate_animations() is running.
var autogen_animation: Animation = null


func _ready() -> void:
	# anytime a widget updates its animations, re-apply them
	HrmnSignalBus.animations_computed.connect(apply_anims)
	# initially apply animations
	apply_animations()
	# connect JSON change signal to re-apply animations
	music_data.changed.connect(apply_animations)


func apply_animations() -> void:
	print_verbose("apply_animations(): start. music_data=%s, music_data._music_data=%s, music_data._music_data_dict=%s" % [music_data, music_data._music_data, "loaded" if music_data._music_data_dict != null else "null"])
	
	# ensure music data is present
	if music_data == null or music_data._music_data == null:
		printerr("apply_animations(): missing Music Data, cannot animate harmonimation widgets.")
		return
	
	# refresh any input filename updates first
	# TODO: I think this isn't necessary anymore?
	print_verbose("apply_animations(): checking for score re-parse")
	music_data._manual_ready()

	# create autogenerated Animation on this Player
	print_verbose("apply_animations(): re-creating autogen animation")
	autogen_animation = Utils.setup_animation(self)
	
	# emit hrmn_animate signal for all widgets to register animations
	HrmnSignalBus.compute_animations.emit(music_data._music_data_dict)

	## loop thru all registered widgets
	#if widgets == null or widgets.size() == 0:
		#print("harmonimation: no widgets to animate")
		#print_verbose("apply_animations(): done (no objects to animate)")
		#return
	#print_verbose("apply_animations(): looping thru %d widgets to set animations" % widgets.size())
	#for widget in widgets:
		#animate_widget(autogen_animation, widget)
	#print("harmonimation: successfully applied music_data to harmonimation widgets!")
	#print_verbose("apply_animations(): done (animations applied)")

func apply_anims(anims: Array[Utils.AnimationStep]) -> void:
	if autogen_animation == null:
		printerr("hrmn_renderer.apply_anims(): unable to apply anims as the autogenerated Animation does not exist right now")
	for anim in anims:
		Utils.apply_animation(anim, self, autogen_animation)

## Compute and apply animation tracks for one widget onto the selected animation track
func animate_widget(animation: Animation, widget: HarmonimationWidget) -> void:
	# TODO: clear all previous animations on this widget
	# determine all animations to apply on this widget, and apply them
	for anim in widget.hrmn_animate(music_data._music_data_dict):
		Utils.apply_animation(anim, self, animation)
	# TODO: also apply initial state to RESET track
