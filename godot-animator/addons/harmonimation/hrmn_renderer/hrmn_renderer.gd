@tool

class_name HarmonimationRenderer
extends Node2D

# TODO: why are there animation tracks at the top of the player with an empty node and a bunch of x's on the track?


#region signals

## Given structured information about the song(music_data: Dictionary):, create a list of animations to play at set times
signal compute_animations

## After a compute_animations signal, Return a list of animations to apply(anims: Array[Utils.AnimationStep])
signal animations_computed

# TODO: define a "animate_config_changed" signal, then call animate_widget when any widget emits it

#endregion


## Data from music score, provided to animation widgets
@export var music_data: MusicScoreData:
	# TODO: catch signals from json data changing
	set(val):
		music_data = val
		# connect JSON change signal to re-apply animations
		music_data.changed.connect(apply_animations)
		if is_node_ready():
			apply_animations()

# TODO: add label to indicate current JSON load state
# TODO: add button to force manually re-compute json


@export var song_audio: AudioStream

@export_tool_button("debug") var debug_action = debug

func debug() -> void:
	print("current animation tracks:")
	print_all_tracks(autogen_animation)


@onready var animation_player: AnimationPlayer = (func() -> AnimationPlayer:
	var players := (self.get_children()
		.filter(func (n: Node) -> bool: return n is AnimationPlayer))
	assert(players.size() != 0, "%s %s expects a direct child of type AnimationPlayer" % [self.get_class(), self.name])
	assert(players.size() < 2, "%s %s expects only one direct child of type AnimationPlayer, but instead there are %d" % [self.get_class(), self.name, players.size()])
	return players[0]
	).call()


## Current animation being created. Only non-null while animate_animations() is running.
var autogen_animation: Animation = null


func _ready() -> void:
	# anytime a widget updates its animations, re-apply them
	self.animations_computed.connect(apply_anims)
	# initially apply animations
	apply_animations()


func apply_animations() -> void:
	if music_data == null:
		print("%s %s apply_animations(): music_data not present, skipping" % [self.get_class(), self.name])
		return
	if not is_node_ready():
		return
	
	assert(animation_player != null, "%s %s apply_animations(): animation_player required" % [self.get_class(), self.name])
	print("apply_animations(): start. music_data=%s, music_data._music_data=%s, music_data._music_data_dict=%s, animation_player=%s" % [music_data, music_data._music_data, "loaded" if music_data._music_data_dict != null else "null", animation_player])
	
	# ensure music data is present
	if music_data == null or music_data._music_data == null:
		printerr("apply_animations(): missing Music Data, cannot animate harmonimation widgets.")
		return
	
	# refresh any input filename updates first
	# TODO: I think this isn't necessary anymore?
	print("apply_animations(): checking for score re-parse")
	music_data._manual_ready()

	# create autogenerated Animation on this Player
	print("apply_animations(): re-creating autogen animation")
	autogen_animation = Utils.setup_animation(animation_player)
	
	# emit hrmn_animate signal for all widgets to register animations
	#print("apply_animations(): emitting hrmn_animate signel")
	#self.compute_animations.emit(music_data._music_data_dict)
	
	# find all widgets in the tree to animate

	# loop thru all registered widgets
	#if widgets == null or widgets.size() == 0:
		#print("harmonimation: no widgets to animate")
		#print_verbose("apply_animations(): done (no objects to animate)")
		#return
	var widgets := self.find_children("*", "HarmonimationWidget")
	print_verbose("apply_animations(): looping thru %d widgets to set animations" % widgets.size())
	for widget in widgets:
		animate_widget(autogen_animation, widget)
	
	# Add audio track
	# TODO: automate. superclass for AnimationStep?
	var audio_track_idx = autogen_animation.add_track(Animation.TYPE_AUDIO)
	autogen_animation.track_set_path(audio_track_idx, animation_player.get_node(animation_player.root_node).get_path_to($AudioStreamPlayer))
	autogen_animation.audio_track_insert_key(audio_track_idx, 2.0, song_audio)

	#await get_tree().create_timer(1).timeout # assume animations are all added now
	print("apply_animations(): list of current tracks:")
	print_all_tracks(autogen_animation)

	print("harmonimation: successfully applied music_data to harmonimation widgets!")
	print_verbose("apply_animations(): done (animations applied)")


func apply_anims(anims: Array[Utils.AnimationStep]) -> void:
	print("harmonimation: running apply_animations() on behalf of %s" % [anims[0].node.name])
	if autogen_animation == null:
		printerr("hrmn_renderer.apply_anims(): unable to apply anims as the autogenerated Animation does not exist right now")
	for anim in anims:
		Utils.apply_animation(anim, animation_player, autogen_animation)
	print_verbose("harmonimation: successfully applied music_data to harmonimation widgets!")


## Compute and apply animation tracks for one widget onto the selected animation track
func animate_widget(animation: Animation, widget: HarmonimationWidget) -> void:
	# TODO: clear all previous animations on this widget
	# determine all animations to apply on this widget, and apply them
	for anim in widget.hrmn_animate(music_data._music_data_dict):
		Utils.apply_animation(anim, animation_player, animation)
	# TODO: also apply initial state to RESET track


func print_all_tracks(animation: Animation) -> void:
	for track_idx in autogen_animation.get_track_count():
		var track_type := autogen_animation.track_get_type(track_idx)
		var track_path := autogen_animation.track_get_path(track_idx)
		print("  track %2d: type=%s, path=%s" % [track_idx, track_type, track_path])
	
