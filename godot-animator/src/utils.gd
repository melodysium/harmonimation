# NOTE: because this is a project autoload, if I want to re-load it for testing changes, I need to reload the whole project
# TODO: move into harmonimation plugin
@tool

extends Node

## Font to use in harmonimation widgets
var DEFAULT_FONT := preload("res://assets/Hack-Regular.ttf")

# TODO: fix typing & warning here
var MUSIC_DATA: Dictionary = load_json_to_dict("res://assets/my_time_data.json").v
	#Dictionary(
	#TYPE_STRING, "", null,
	#TYPE_MAX, "", null) # TODO: this is wrong. can I find the TYPE_VARIANT that doesn't seem to exist?

## Name for auto-generated Animations
const ANIMATION_NAME_AUTOGEN := "animate_harmonimation_autogenerated"


# TODO: there's actually just printerr(). why is this here?
func print_err(...args: Array) -> void:
	print_rich("[color=red]", "".join(args), "[/color]")
	
## Typing workaround. "<val> as Array" triggers UNSAFE_CAST warning, so this workaround is preferred for now
func as_array(val: Variant) -> Array:
	return val


class OptionalDictionary:
	var v: Dictionary
	func _init(dict: Dictionary) -> void:
		v = dict


func load_json_to_dict(json_file: String) -> OptionalDictionary:
	var json := load_json(json_file)
	if json == null:
		return null
	return json_to_dict(json)


func load_json(json_file: String) -> JSON:
	var json_string := FileAccess.get_file_as_string(json_file)
	var json := JSON.new()
	var error := json.parse(json_string)
	if error != OK:
		print_err("ERROR(load_json): JSON Parse Error: ", json.get_error_message(), " in ", json_string, " at line ", json.get_error_line())
		return null;
	print_verbose("Successfully loaded json file %s" % json_file)
	return json


func json_to_dict(json: JSON) -> OptionalDictionary:
	if typeof(json.data) == TYPE_DICTIONARY:
		var json_dict: Dictionary = json.data
		print_verbose("json is a dictionary with %d keys: %s" % [json_dict.size(), json_dict.keys().map(
			func(key: String) -> String: return "%s: %s" % [key, type_string(typeof(json_dict[key]))]
		)])
		return OptionalDictionary.new(json_dict)
	else:
		print_err("ERROR(load_json_to_dict): Unexpected json data type: " + type_string(typeof(json.data)))
		return null


## Fill an array with the same element n times.
## WARNING: `elem` is not deep cloned when adding. Modifying the element will modify all elements of the array.
func fill_array(size: int, elem: Variant) -> Array:
	print_verbose("start Utils.fill_array(size=%s, elem=%s)" % [size, elem])
	var arr := []
	for i in range(size):
		arr.append(elem)
	print_verbose("end Utils.fill_array(), return=%s" % [arr])
	return arr


## Given an Array[T] and a Callable[[T], Dictionary[A, B], return a single Dictionary[A, B]
#func collect_to_dict(arr: Array, map: Callable) -> Dictionary:
	#return (arr.map(map)
			#.reduce(func (d: Dictionary, e: Dictionary) -> Dictionary:
				#return d.merged(e)))


## Represents a single Pitch name, with multiple ways of displaying it as a string.
class Pitch:

	# TODO: make into Dictionary[Dictionary[String, Variant]] for more info
	const _PITCH_CLASS_NAME_MAPPING := {
		0: "C",
		1: "D♭",
		2: "D",
		3: "E♭",
		4: "E",
		5: "F",
		6: "G♭",
		7: "G",
		8: "A♭",
		9: "A",
		10: "B♭",
		11: "B",
	}

	# TODO: support customization on sharp/flat, natural, etc
	static func pitchclass_to_pitchname(pitch_class: int) -> String:
		return _PITCH_CLASS_NAME_MAPPING[pitch_class % 12]

## Single key frame on the AnimationPlayer track
class PropertyKeyframe:
	var value: Variant
	var transition: float
	
	func _init(
		_value: Variant,
		_transition: float = 0.0
	) -> void:
		self.value = _value
		self.transition = _transition


## Describes a single property with a list of sequential values to animate
class PropertyChange:
	var property_name: String
	var values: Array[PropertyKeyframe]

	func _init(
		_property_name: String,
		_values: Array[PropertyKeyframe],
	) -> void:
		self.property_name = _property_name
		self.values = _values
	
	static func pair(
		_property_name: String,
		_val_start: Variant,
		_val_end: Variant,
		_transition_start: float=-4.0,
		_transition_end: float=0.0,
	) -> PropertyChange:
		return PropertyChange.new(
			_property_name,
			[
				PropertyKeyframe.new(_val_start, _transition_start),
				PropertyKeyframe.new(_val_end, _transition_end),
			]
		)


## Describes animating one or more properties of a given Node over a given time range.
class AnimationStep:
	var times: PackedFloat32Array
	var node_changes: Dictionary[Node, Array] # Dictionary[Node, Array[PropertyChange]]

	func _init(
		_times: PackedFloat32Array,
		_node_changes: Dictionary[Node, Array]
	) -> void:
		# check assumptions
		assert(_times.size() >= 1, "AnimationStep.init(%s, %s): cannot accept a times array with 0 elements" % [_times, _node_changes])
		assert(_node_changes.size() >= 1, "AnimationStep.init(%s, %s): cannot accept an empty _node_changes map" % [_times, _node_changes])

		# validate _node_changes elements
		for node: Node in _node_changes.keys():
			assert(node != null, "AnimationStep.init(%s, %s): cannot accept a null node in _node_changes map" % [_times, _node_changes])
			var array_prop_changes: Array = _node_changes[node] # Array[PropertyChange]
			# validate each prop_change
			for prop_change: PropertyChange in array_prop_changes:
				assert(prop_change != null, "AnimationStep.init(%s, %s): cannot accept a null PropertyChange" % [_times, _node_changes])
				assert(prop_change.values.size() == _times.size(), "AnimationStep.init(%s, %s): cannot accept a PropertyChange for property %s of len %d (should match times.size() of %d)" % [_times, _node_changes, prop_change.property_name, prop_change.values.size(), _times.size()])
		
		# init
		self.times = _times
		self.node_changes = _node_changes


# TODO: deal with magic number
## Find/make the animation used for auto-generated animations
func setup_animation(player: AnimationPlayer, animation_length: float = 200.0, delete_existing := true) -> Animation:
	if not player.has_animation_library(""):
		print("AnimationPlayer doesn't yet have the global library. adding it...")
		player.add_animation_library("", AnimationLibrary.new())
	var library := player.get_animation_library("") # "" means "get global library"

	# if delete_existing always, then delete any pre-existing animation
	if delete_existing and library.has_animation(Utils.ANIMATION_NAME_AUTOGEN):
		library.remove_animation(Utils.ANIMATION_NAME_AUTOGEN)

	# Find or make an Animation
	var animation: Animation = null
	# If animation already exists, just fetch it
	if library.has_animation(Utils.ANIMATION_NAME_AUTOGEN):
		animation = library.get_animation(Utils.ANIMATION_NAME_AUTOGEN)
	else:
		# create new animation to use, add it to the library
		animation = Animation.new()
		animation.length = animation_length
		library.add_animation(Utils.ANIMATION_NAME_AUTOGEN, animation)

	# print some debug information about the animation
	print_verbose("animation: %s(%s), track_count=%d" % [animation.resource_name, animation, animation.get_track_count()])
	for i in range(animation.get_track_count()):
		print_verbose("animation track %d. path=%s, type=%s" % [i, animation.track_get_path(i), animation.track_get_type(i)])
	return animation


## Create at runtime an Animation on the specified AnimationPlayer with the specified animation properties.
func apply_animation(animation_step: Utils.AnimationStep, player: AnimationPlayer, animation: Animation) -> void:
	# TODO: make configurable whether to delete existing track if it exists
	print("Utils.apply_animation(%s, %s, %s): start" % [
		animation_step.node_changes.keys().map(func (n: Node) -> String: return n.name),
		animation_step.times,
		animation_step.node_changes.values()[0].map(func(pc: PropertyChange) -> String: return pc.property_name)
		])

	# Loop over all nodes to animate
	for node: Node in animation_step.node_changes.keys():
		var property_changes: Array = animation_step.node_changes[node]
		var path_to_puppet_node := player.get_node(player.root_node).get_path_to(node)
		
		# Loop over each property to set on this node
		for property_change: PropertyChange in property_changes:
			var path_to_puppet_property := "%s:%s" % [path_to_puppet_node, property_change.property_name]
			var track_idx := animation.find_track(path_to_puppet_property, Animation.TYPE_VALUE)
			# if track doesn't exist yet for this property, add it
			if track_idx == -1:
				track_idx = animation.add_track(Animation.TYPE_VALUE)
				animation.track_set_path(track_idx, path_to_puppet_property)
			print_verbose("  node=%s, prop_name=%s, track_idx=%d", node.name, property_change.property_name, track_idx)

			# Set keyframes at different times:
			for i in range(animation_step.times.size()):
				var keyframe := property_change.values[i]
				animation.track_insert_key(track_idx, animation_step.times[i], keyframe.value, keyframe.transition)
				print_verbose("    added keyframe for (%fs: val=%s, easing=%f)" % [animation_step.times[i], keyframe.value, keyframe.transition])
