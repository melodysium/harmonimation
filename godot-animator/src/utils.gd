# NOTE: because this is a project autoload, if I want to re-load it for testing changes, I need to reload the whole project
# TODO: move into harmonimation plugin
@tool

extends Node

## Font to use in harmonimation widgets
var DEFAULT_FONT := preload("res://assets/Hack-Regular.ttf")

# TODO: fix typing & warning here
var MUSIC_DATA: Dictionary = load_json_to_dict("res://assets/my_time_data.json").v
	#Dictionary(
	#TYPE_STRING, "", null,
	#TYPE_MAX, "", null) # TODO: this is wrong. can I find the TYPE_VARIANT that doesn't seem to exist?

## Name for auto-generated Animations
const ANIMATION_NAME_AUTOGEN := "animate_harmonimation_autogenerated"


# TODO: there's actually just printerr(). why is this here?
func print_err(...args: Array) -> void:
	print_rich("[color=red]", "".join(args), "[/color]")
	
## Typing workaround. "<val> as Array" triggers UNSAFE_CAST warning, so this workaround is preferred for now
func as_array(val: Variant) -> Array:
	return val


class OptionalDictionary:
	var v: Dictionary
	func _init(dict: Dictionary) -> void:
		v = dict


func load_json_to_dict(json_file: String) -> OptionalDictionary:
	var json := load_json(json_file)
	if json == null:
		return null
	return json_to_dict(json)


func load_json(json_file: String) -> JSON:
	var json_string := FileAccess.get_file_as_string(json_file)
	var json := JSON.new()
	var error := json.parse(json_string)
	if error != OK:
		print_err("ERROR(load_json): JSON Parse Error: ", json.get_error_message(), " in ", json_string, " at line ", json.get_error_line())
		return null;
	print_verbose("Successfully loaded json file %s" % json_file)
	return json


func json_to_dict(json: JSON) -> OptionalDictionary:
	if typeof(json.data) == TYPE_DICTIONARY:
		var json_dict: Dictionary = json.data
		print_verbose("json is a dictionary with %d keys: %s" % [json_dict.size(), json_dict.keys().map(
			func(key: String) -> String: return "%s: %s" % [key, type_string(typeof(json_dict[key]))]
		)])
		return OptionalDictionary.new(json_dict)
	else:
		print_err("ERROR(load_json_to_dict): Unexpected json data type: " + type_string(typeof(json.data)))
		return null


## Fill an array with the same element n times.
## WARNING: `elem` is not deep cloned when adding. Modifying the element will modify all elements of the array.
func fill_array(size: int, elem: Variant) -> Array:
	print_verbose("start Utils.fill_array(size=%s, elem=%s)" % [size, elem])
	var arr := []
	for i in range(size):
		arr.append(elem)
	print_verbose("end Utils.fill_array(), return=%s" % [arr])
	return arr


## Given an Array[T] and a Callable[[T], Dictionary[A, B], return a single Dictionary[A, B]
#func collect_to_dict(arr: Array, map: Callable) -> Dictionary:
	#return (arr.map(map)
			#.reduce(func (d: Dictionary, e: Dictionary) -> Dictionary:
				#return d.merged(e)))


## Represents a single Pitch name, with multiple ways of displaying it as a string.
class Pitch:

	# TODO: make into Dictionary[Dictionary[String, Variant]] for more info
	const _PITCH_CLASS_NAME_MAPPING := {
		0: "C",
		1: "D♭",
		2: "D",
		3: "E♭",
		4: "E",
		5: "F",
		6: "G♭",
		7: "G",
		8: "A♭",
		9: "A",
		10: "B♭",
		11: "B",
	}

	# TODO: support customization on sharp/flat, natural, etc
	static func pitchclass_to_pitchname(pitch_class: int) -> String:
		return _PITCH_CLASS_NAME_MAPPING[pitch_class % 12]

## Single key frame with a "lead-in" time to animate if no closer preceding keyframe
class PropertyKeyframePoint:
	## The value to set on the property being animated at this keyframe.
	var value: Variant
	## The time at which to place this keyframe in the animation timeline.
	var time: float
	## Optional. Controls the transition (easing) for this main keyframe.
	var transition: float
	## Optional. If > 0, will try to add another keyframe at (time - lead_in_timespan) with value <previous.value> and transition <this.transition>.
	var lead_in_timespan: float
	## Optional. Paired with lead_in_timespan. Set the transition (easing) of a lead-in keyframe.
	var lead_in_transition: float

	func _init(
		_value: Variant,
		_time: float,
		_transition: float = 0.0,
		_lead_in_timespan: float = 0.0,
		_lead_in_transition: float = 0.0,
	) -> void:
		self.value = _value
		self.time = _time
		self.transition = _transition
		self.lead_in_timespan = _lead_in_timespan
		self.lead_in_transition = _lead_in_transition


# TODO: probably don't need this, just use Dict[N, Dict[Str, Arr[Keyframe]]] as a function arg
class AnimationSpec:
	var nodes: Dictionary[Node, Dictionary] # Dictionary[Node, Dictionary[String(property), Array[Keyframe]]


func merge_animations(a1: Dictionary[Node, Dictionary], a2: Dictionary[Node, Dictionary]) -> Dictionary[Node, Dictionary]:
	var ret: Dictionary[Node, Dictionary] = Dictionary(a1,
		TYPE_OBJECT, "Node", null,
		TYPE_DICTIONARY, "", null,)
	for node: Node in a2.keys():
		if !ret.has(node):
			# copy and set from a2 to ret
			ret[node] = Dictionary(a2[node],
				TYPE_STRING, "", null,
				TYPE_ARRAY, "", null,)
		else:
			# merge dictionaries per mode
			for property_name: String in a2.values():
				var a2_arr: Array = a2[node][property_name]
				if !ret[node].has(property_name):
					# copy and set froma a2 to ret
					ret[node][property_name] = Array(a2_arr,
						TYPE_OBJECT, "PropertyKeyframePoint", null)
				else:
					# arrays exist for both; join them
					var ret_arr: Array = ret[node][property_name]
					ret_arr.append_array(a2_arr)
	return ret


# TODO: deal with magic number
## Find/make the animation used for auto-generated animations
func setup_animation(player: AnimationPlayer, animation_length: float = 200.0, delete_existing := true) -> Animation:
	if not player.has_animation_library(""):
		print("AnimationPlayer doesn't yet have the global library. adding it...")
		player.add_animation_library("", AnimationLibrary.new())
	var library := player.get_animation_library("") # "" means "get global library"

	# if delete_existing always, then delete any pre-existing animation
	if delete_existing and library.has_animation(Utils.ANIMATION_NAME_AUTOGEN):
		library.remove_animation(Utils.ANIMATION_NAME_AUTOGEN)

	# Find or make an Animation
	var animation: Animation = null
	# If animation already exists, just fetch it
	if library.has_animation(Utils.ANIMATION_NAME_AUTOGEN):
		animation = library.get_animation(Utils.ANIMATION_NAME_AUTOGEN)
	else:
		# create new animation to use, add it to the library
		animation = Animation.new()
		animation.length = animation_length
		library.add_animation(Utils.ANIMATION_NAME_AUTOGEN, animation)

	# print some debug information about the animation
	print_verbose("animation: %s(%s), track_count=%d" % [animation.resource_name, animation, animation.get_track_count()])
	for i in range(animation.get_track_count()):
		print_verbose("animation track %d. path=%s, type=%s" % [i, animation.track_get_path(i), animation.track_get_type(i)])
	return animation


## Create at runtime an Animation on the specified AnimationPlayer with the specified animation properties.
## animation_step full type: Dictionary[Node, Dictionary[String(property), Array[PropertyKeyframePoint]]
func apply_animation(animation_step: Dictionary[Node, Dictionary], player: AnimationPlayer, animation: Animation) -> void:
	# TODO: make configurable whether to delete existing track if it exists
	print("Utils.apply_animation(%s, %s, %s): start" % [
		animation_step.keys().map(func (n: Node) -> String: return n.name),
		animation_step.values()[0].keys(),
		animation_step.values()[0].values()[0].map(func (k: PropertyKeyframePoint) -> float: return k.time)
		])


	# Loop over all nodes to animate
	for node: Node in animation_step.keys():
		var property_changes: Dictionary = animation_step[node] # Dictionary[String, Array[PropertyKeyframePoint]] NOTE: type hinting seems to break here with weird "cant cast <X> to <X>" errors
		var path_to_puppet_node := player.get_node(player.root_node).get_path_to(node)
		
		# Loop over each property to set on this node
		for property_name: String in property_changes.keys():
			var keyframes: Array = property_changes[property_name] # Array[PropertyKeyframePoint] NOTE: type hinting seems to break here with weird "cant cast <X> to <X>" errors
			
			var path_to_puppet_property := "%s:%s" % [path_to_puppet_node, property_name]
			var track_idx := animation.find_track(path_to_puppet_property, Animation.TYPE_VALUE)
			# if track doesn't exist yet for this property, add it
			if track_idx == -1:
				track_idx = animation.add_track(Animation.TYPE_VALUE)
				animation.track_set_path(track_idx, path_to_puppet_property)
			print_verbose("  node=%s, prop_name=%s, track_idx=%d", node.name, property_name, track_idx)

			# Set keyframes at different times:
			var previous_keyframe: PropertyKeyframePoint = null
			for keyframe: PropertyKeyframePoint in keyframes:
				animation.track_insert_key(track_idx, keyframe.time, keyframe.value, keyframe.transition)
				print_verbose("    added keyframe for (%fs: val=%s, easing=%f)" % [keyframe.time, keyframe.value, keyframe.transition])
				
				if keyframe.lead_in_timespan > 0:
					# try to add a lead-in keyframe too
					var lead_in_time := keyframe.time - keyframe.lead_in_timespan
					if previous_keyframe != null:
						# only add lead-in keyframe if lead_in_time comes after the previous keyframe
						if lead_in_time > previous_keyframe.time:
							animation.track_insert_key(track_idx, lead_in_time, previous_keyframe.value, keyframe.lead_in_transition)
							print_verbose("    added lead-in keyframe for (%fs: val=%s, easing=%f)" % [lead_in_time, previous_keyframe.value, keyframe.lead_in_transition])
						else:
							# set transition on previous keyframe to animate into this one
							var key_idx := animation.track_find_key(track_idx, previous_keyframe.time, Animation.FindMode.FIND_MODE_EXACT)
							animation.track_set_key_transition(track_idx, key_idx, keyframe.lead_in_transition)
					else:
						pass # TODO: maybe I can set some default value here? for now, just expect widgets to set a keyframe at time=0 with no lead-in
						printerr("Cannot add a lead-in keyframe on the first keyframe of a track, as I don't know what previous value to set.")
				previous_keyframe = keyframe
