@tool

extends Node


var DEFAULT_FONT := preload("res://assets/Hack-Regular.ttf")

# TODO: fix typing & warning here
var MUSIC_DATA: Dictionary = Dictionary(json_to_dict("res://assets/my_time_data.json"))
	#Dictionary(
	#TYPE_STRING, "", null,
	#TYPE_MAX, "", null) # TODO: this is wrong. can I find the TYPE_VARIANT that doesn't seem to exist?

## Name for auto-generated Animations
const ANIMATION_NAME_AUTOGEN := "animate_harmonimation_autogenerated"


func print_err(...args: Array) -> void:
	print_rich("[color=red]", "".join(args), "[/color]")


func json_to_dict(json_file: String) -> Variant: # Optional[Dictionary]
	var json_string := FileAccess.get_file_as_string(json_file)
	var json := JSON.new()
	var error := json.parse(json_string)
	if error != OK:
		print_err("ERROR(json_to_dict): JSON Parse Error: ", json.get_error_message(), " in ", json_string, " at line ", json.get_error_line())
		return null;
	if typeof(json.data) == TYPE_DICTIONARY:
		return json.data
	else:
		print_err("ERROR(json_to_dict): Unexpected json data type: " + type_string(typeof(json.data)))
		return null


## Fill an array with the same element n times.
## WARNING: `elem` is not copied when adding. Modifying the element will modify all elements of the array.
func fill_array(size: int, elem: Variant) -> Array:
	print_verbose("start Utils.fill_array(size=%s, elem=%s)" % [size, elem])
	var arr := []
	for i in range(size):
		arr.append(elem)
	print_verbose("end Utils.fill_array(), return=%s" % [arr])
	return arr


## Represents a single Pitch name, with multiple ways of displaying it as a string.
class Pitch:

	# TODO: make into Dictionary[Dictionary[String, Variant]] for more info
	const _PITCH_CLASS_NAME_MAPPING := {
		0: "C",
		1: "D♭",
		2: "D",
		3: "E♭",
		4: "E",
		5: "F",
		6: "G♭",
		7: "G",
		8: "A♭",
		9: "A",
		10: "B♭",
		11: "B",
	}

	# TODO: support customization on sharp/flat, natural, etc
	static func pitchclass_to_pitchname(pitch_class: int) -> String:
		return _PITCH_CLASS_NAME_MAPPING[pitch_class % 12]

## Describes a single property with a before-and-after value
class PropertyChange:
	var property_name: String
	var val_start: Variant
	var val_end: Variant

	func _init(
		_property_name: String,
		_val_start: Variant,
		_val_end: Variant
	) -> void:
		self.property_name = _property_name
		self.val_start = _val_start
		self.val_end = _val_end

## Describes animating one or more properties of a given Node over a fixed time range.
class AnimationStep:
	var node: Node
	var time_start: float
	var time_end: float
	var property_changes: Array[PropertyChange]

	func _init(
		_node: Node,
		_time_start: float,
		_time_end: float,
		_property_changes: Array[PropertyChange]
	) -> void:
		self.node = _node
		self.time_start = _time_start
		self.time_end = _time_end
		self.property_changes = _property_changes


## Create at runtime an Animation on the specified AnimationPlayer with the specified animation properties.
func apply_animation(animation_step: Utils.AnimationStep, player: AnimationPlayer) -> void:
	# TODO: separate out getting animation to apply to
	# TODO: make configurable whether to delete existing track if it exists

	# Find/make the animation used for auto-generated animations
	var library := player.get_animation_library("") # "" means "get global library"
	if library.has_animation(Utils.ANIMATION_NAME_AUTOGEN):
		# delete it
		library.remove_animation(Utils.ANIMATION_NAME_AUTOGEN)
	# create new animation to use, add it to the library
	var animation := Animation.new()
	animation.length = 10.0
	library.add_animation(Utils.ANIMATION_NAME_AUTOGEN, animation)
	print("animation: %s(%s), track_count=%d" % [animation.resource_name, animation, animation.get_track_count()])
	for i in range(animation.get_track_count()):
		print("animation track %d. path=%s, type=%s" % [i, animation.track_get_path(i), animation.track_get_type(i)])

	# Set up animation tracks for the requested AnimationStep
	var path_to_me := player.get_node(player.root_node).get_path_to(animation_step.node)
	for property_change in animation_step.property_changes:
		var path_to_me_property := "%s:%s" % [path_to_me, property_change.property_name]
		var track_idx := animation.find_track(path_to_me_property, Animation.TYPE_VALUE)
		# if track doesn't exist yet for this property, add it
		if track_idx == -1:
			track_idx = animation.add_track(Animation.TYPE_VALUE)
			animation.track_set_path(track_idx, path_to_me_property)
		print_verbose("track: ", track_idx)

		# Set start and end keyframes
		animation.track_insert_key(track_idx, animation_step.time_start, property_change.val_start, -4.0)
		animation.track_insert_key(track_idx, animation_step.time_end, property_change.val_end, 0)
